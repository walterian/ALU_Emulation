
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ALU_emulation</title><meta name="generator" content="MATLAB 9.2"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2017-05-09"><meta name="DC.source" content="ALU_emulation.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">function</span> varargout = ALU_emulation(varargin)
<span class="comment">% ALU_EMULATION MATLAB code for ALU_emulation.fig</span>
<span class="comment">%      ALU_EMULATION, by itself, creates a new ALU_EMULATION or raises the existing</span>
<span class="comment">%      singleton*.</span>
<span class="comment">%</span>
<span class="comment">%      H = ALU_EMULATION returns the handle to a new ALU_EMULATION or the handle to</span>
<span class="comment">%      the existing singleton*.</span>
<span class="comment">%</span>
<span class="comment">%      ALU_EMULATION('CALLBACK',hObject,eventData,handles,...) calls the local</span>
<span class="comment">%      function named CALLBACK in ALU_EMULATION.M with the given input arguments.</span>
<span class="comment">%</span>
<span class="comment">%      ALU_EMULATION('Property','Value',...) creates a new ALU_EMULATION or raises the</span>
<span class="comment">%      existing singleton*.  Starting from the left, property value pairs are</span>
<span class="comment">%      applied to the APPALU before ALU_emulation_OpeningFcn gets called.  An</span>
<span class="comment">%      unrecognized property name or invalid value makes property application</span>
<span class="comment">%      stop.  All inputs are passed to ALU_emulation_OpeningFcn via varargin.</span>
<span class="comment">%</span>
<span class="comment">%      *See APPALU Options on GUIDE's Tools menu.  Choose "APPALU allows only one</span>
<span class="comment">%      instance to run (singleton)".</span>
<span class="comment">%</span>
<span class="comment">% See also: GUIDE, GUIDATA, GUIHANDLES</span>

<span class="comment">% Edit the above text to modify the response to help ALU_emulation</span>

<span class="comment">% Last Modified by GUIDE v2.5 09-May-2017 07:48:40</span>

<span class="comment">% Begin initialization code - DO NOT EDIT</span>
gui_Singleton = 1;
gui_State = struct(<span class="string">'gui_Name'</span>,       mfilename, <span class="keyword">...</span>
                   <span class="string">'gui_Singleton'</span>,  gui_Singleton, <span class="keyword">...</span>
                   <span class="string">'gui_OpeningFcn'</span>, @ALU_emulation_OpeningFcn, <span class="keyword">...</span>
                   <span class="string">'gui_OutputFcn'</span>,  @ALU_emulation_OutputFcn, <span class="keyword">...</span>
                   <span class="string">'gui_LayoutFcn'</span>,  [] , <span class="keyword">...</span>
                   <span class="string">'gui_Callback'</span>,   []);
<span class="keyword">if</span> nargin &amp;&amp; ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
<span class="keyword">end</span>

<span class="keyword">if</span> nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
<span class="keyword">else</span>
    gui_mainfcn(gui_State, varargin{:});
<span class="keyword">end</span>
<span class="comment">% End initialization code - DO NOT EDIT</span>


<span class="comment">% --- Executes just before ALU_emulation is made visible.</span>
<span class="keyword">function</span> ALU_emulation_OpeningFcn(hObject, eventdata, handles, varargin)
<span class="comment">% This function has no output args, see OutputFcn.</span>
<span class="comment">% hObject    handle to figure</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>
<span class="comment">% varargin   command line arguments to ALU_emulation (see VARARGIN)</span>

<span class="comment">% Choose default command line output for ALU_emulation</span>
handles.output = hObject;

<span class="comment">% Update handles structure</span>
guidata(hObject, handles);

<span class="comment">% UIWAIT makes ALU_emulation wait for user response (see UIRESUME)</span>
<span class="comment">% uiwait(handles.appalu);</span>


<span class="comment">% --- Outputs from this function are returned to the command line.</span>
<span class="keyword">function</span> varargout = ALU_emulation_OutputFcn(hObject, eventdata, handles)
<span class="comment">% varargout  cell array for returning output args (see VARARGOUT);</span>
<span class="comment">% hObject    handle to figure</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Get default command line output from handles structure</span>
varargout{1} = handles.output;


<span class="comment">% --- Executes on button press in buttonExit.</span>
<span class="keyword">function</span> buttonExit_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonExit (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">%this line deletes the shell of the program, which causes the program to</span>
<span class="comment">%close</span>
delete(handles.appalu)


<span class="comment">% --- Executes on button press in buttonRun.</span>
<span class="keyword">function</span> buttonRun_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonRun (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

axes(handles.axes1);
cla;
tic;

timev(1) = toc;
<span class="comment">%by default the output will not be in twos complement format, so we want</span>
<span class="comment">%the text box that displays that the output is in twos complement notation</span>
<span class="comment">%to invisible</span>
set(handles.twoscomptextbox,<span class="string">'Visible'</span>,<span class="string">'off'</span>);
set(handles.checkConvert,<span class="string">'Visible'</span>,<span class="string">'off'</span>);


<span class="comment">%these if statements check if either of the input operands are blank, and</span>
<span class="comment">%if they are puts a 0 in them so the program does not throw any errors</span>
<span class="keyword">if</span> get(handles.operandA,<span class="string">'String'</span>) == <span class="string">""</span>
    set(handles.operandA,<span class="string">'String'</span>,<span class="string">'0'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> get(handles.operandB,<span class="string">'String'</span>) == <span class="string">""</span>
    set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);
<span class="keyword">end</span>
<span class="keyword">if</span> get(handles.carryinput,<span class="string">'String'</span>) == <span class="string">""</span>
    set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
<span class="keyword">end</span>

timev(2) = toc;

<span class="comment">%these lines convert the values in the input boxes from string to unsigned</span>
<span class="comment">%8 bit integer values</span>
opA = str2num(get(handles.operandA,<span class="string">'String'</span>));
cast(opA,<span class="string">'uint8'</span>);
opB = str2num(get(handles.operandB,<span class="string">'String'</span>)); <span class="comment">%#ok&lt;*ST2NM&gt;</span>
cast(opB,<span class="string">'uint8'</span>);
<span class="comment">%the #ok&lt;*ST2NM&gt; is included to prevent str2num from showing a warning</span>

<span class="comment">%these lines make sure the ALU only takes in the first eight bits of data</span>
<span class="comment">%passed to it in each operand input, as would happen in a real ALU</span>
opA = mod(opA,256);
opB = mod(opB,256);

<span class="comment">%these two set() statements are what display the inputs as decimal numbers</span>
<span class="comment">%in the Display container.</span>
set(handles.textDecimalA,<span class="string">'String'</span>,opA)
set(handles.textDecimalB,<span class="string">'String'</span>,opB)

timev(3) = toc;

<span class="comment">%these lines convert each operand to the binary 8 bit equivalent of the</span>
<span class="comment">%integers that were input in the operandA and operandB text boxes.  de2bi()</span>
<span class="comment">%was used here instead of creating our own function because in creating our</span>
<span class="comment">%own function that would utilize dividing the number by 2^n in an iterative</span>
<span class="comment">%statement, we encountered the issue that because Matlab is such a high</span>
<span class="comment">%level program, it "smartly" deals with dividing two integer values by</span>
<span class="comment">%assigning the value that they are equal to to be a float type, so we were</span>
<span class="comment">%getting back decimals.  Even using a function that returned the value of</span>
<span class="comment">%the two as an integer still rounded up if the decimal was greater than .5.</span>
<span class="comment">%Because of these, and since our project was not to create a decimal to</span>
<span class="comment">%binary converter, we utilizes one of the functions that was available to</span>
<span class="comment">%us through the Matlab library.</span>
opA = de2bi(opA,8,<span class="string">'left-msb'</span>);
opB = de2bi(opB,8,<span class="string">'left-msb'</span>);

<span class="comment">%these set the strings of the text boxes that have the tags textBinaryA and</span>
<span class="comment">%textBinaryB to the string equivalent of each binary number</span>
set(handles.textBinaryA,<span class="string">'String'</span>,num2str(opA));
set(handles.textBinaryB,<span class="string">'String'</span>,num2str(opB));

timev(4) = toc;

<span class="comment">%this checks the validity of the value entered in the carryin text box.  If</span>
<span class="comment">%it is greater than 1, the value will be set down to 1 as the only valid</span>
<span class="comment">%carryin values are 1 or 0. There is no way for an actual ALU to take in any</span>
<span class="comment">%input in carryin that is greater than 1.</span>
carryin = str2num(get(handles.carryinput,<span class="string">'String'</span>));
<span class="keyword">if</span> carryin &gt; 1
    set(handles.carryinput,<span class="string">'String'</span>,<span class="string">"1"</span>)
    carryin = 1;
<span class="keyword">end</span>
set(handles.textcarryin,<span class="string">'String'</span>,num2str(carryin));
carryin = de2bi(carryin,8,<span class="string">'left-msb'</span>);
carryout = 0;

<span class="comment">%defines a binary 1 to be used in functionalities such as increment and</span>
<span class="comment">%decrement</span>
bione = de2bi(1,8,<span class="string">'left-msb'</span>);

timev(5) = toc;

<span class="comment">%these ifs check which radio button is selected (the buttons in the Opcode</span>
<span class="comment">%panel) and based on that, perform some function specified</span>
<span class="keyword">if</span> get(handles.buttonAdd,<span class="string">'Value'</span>)
    <span class="comment">%calls funtion addnumbers() to add opA and opB, and also needs carryout</span>
    <span class="comment">%as it is used within the function and then returned</span>
    [sum,carryout] = addnumbers(opA, opB, carryout);

    <span class="comment">%print out the sum in the main output, carryout in the status output,</span>
    <span class="comment">%and handles is needed in order to actually access the various elements</span>
    <span class="comment">%in the gui that display these values</span>
    printoutput(sum,carryout,handles)

<span class="keyword">elseif</span> get(handles.buttonSubtract,<span class="string">'Value'</span>)
    <span class="comment">%calls function addnumbers() to add operand A with the twos complement</span>
    <span class="comment">%of operand B, which is how subtraction is done in an ALU</span>
    [diff,carryout] = addnumbers(opA, twoscomp(opB), carryout);

    <span class="comment">%these lines print the result of adding the two, and if operand B was</span>
    <span class="comment">%larger than operand A, it makes the text box saying "Twos Comp"</span>
    <span class="comment">%visible, as the result will be in twos complement form</span>
    <span class="keyword">if</span> bi2de(opB,<span class="string">'left-msb'</span>) &gt; bi2de(opA,<span class="string">'left-msb'</span>)
        set(handles.twoscomptextbox,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
        set(handles.checkConvert,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
    <span class="keyword">end</span>
    printoutput(diff,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonAddCarry,<span class="string">'Value'</span>)
    <span class="comment">%these lines add the carryin to opA, and that sum is then added to opB</span>
    [sum,carryout] = addnumbers(carryin, opA, carryout);
    [sum,carryout] = addnumbers(sum, opB, carryout);

    printoutput(sum,carryout,handles)

<span class="keyword">elseif</span> get(handles.buttonSubBorrow,<span class="string">'Value'</span>)
    <span class="comment">%this section is very similar to the previous subtraction section, with</span>
    <span class="comment">%the change being that the carryin bit is added to opA before adding</span>
    <span class="comment">%that to the two's complement of opB</span>
    [opAtotal,carryout] = addnumbers(opA, carryin, carryout);
    [diff,carryout] = addnumbers(opAtotal, twoscomp(opB), carryout);

    <span class="comment">%checks if the output is in two's complement format</span>
    <span class="keyword">if</span> bi2de(opB,<span class="string">'left-msb'</span>)&gt;bi2de(opAtotal,<span class="string">'left-msb'</span>)
        set(handles.twoscomptextbox,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
        set(handles.checkConvert,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
    <span class="keyword">end</span>

    printoutput(diff,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonTwosComplement,<span class="string">'Value'</span>)
    <span class="comment">%calls the twoscomp() of opA</span>
    [mainout,carryout] = twoscomp(opA);

    printoutput(mainout,carryout,handles)
    <span class="comment">%enables the box indicating the value is in two's complement format and</span>
    <span class="comment">%the check box to convert that to it's signed integer value.</span>
    set(handles.twoscomptextbox,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
    set(handles.checkConvert,<span class="string">'Visible'</span>,<span class="string">'on'</span>);

<span class="keyword">elseif</span> get(handles.buttonIncrement,<span class="string">'Value'</span>)
    <span class="comment">%adds opA with binary one, incrementing opA by 1</span>
    [sum,carryout] = addnumbers(opA, bione, carryout);

    printoutput(sum,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonDecrement,<span class="string">'Value'</span>)
    <span class="comment">%this line gets the two's complement of bione and sets twosOne equal to</span>
    <span class="comment">%that value</span>
    [twosOne, carryout] = twoscomp(bione);

    [sum,carryout] = addnumbers(opA, twosOne, carryout);

    <span class="comment">%this checks if operand A is equal to 0, the only instance where the</span>
    <span class="comment">%output of this function can be in two's complement form</span>
    <span class="keyword">if</span> bi2de(opA) == 0
        set(handles.twoscomptextbox,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
        set(handles.checkConvert,<span class="string">'Visible'</span>,<span class="string">'on'</span>);
    <span class="keyword">end</span>

    printoutput(sum,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonAND,<span class="string">'Value'</span>)
    <span class="comment">%steps through each element of the arrays opA and opB and checks if</span>
    <span class="comment">%both are equal to one: if they are, then the value at that column of</span>
    <span class="comment">%anded is set to one; otherwise, it is set to 0</span>
    anded(1:8) = opA(1:8) &amp; opB(1:8);

    printoutput(anded,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonOR,<span class="string">'Value'</span>)
    <span class="comment">%steps through element by element of the arrays and if either element</span>
    <span class="comment">%it is currently checking is a 1, it outputs a 1 to numsORed; otherwise</span>
    <span class="comment">%it is set to 0</span>
    numsORed(1:8) = opA(1:8) | opB(1:8);

    printoutput(numsORed,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonXOR,<span class="string">'Value'</span>)
    <span class="comment">%goes through each element of each array one by one: first it checks if</span>
    <span class="comment">%at least one element has a value of 1 in that column; then it gets the</span>
    <span class="comment">%NANDed value of the two anded together, which is to say it makes sure</span>
    <span class="comment">%that not both have a value of 1; finally it sets numsXORed at that</span>
    <span class="comment">%column equal to 1 if both of these criteria have been met, else 0</span>
    numsXORed(1:8) = ((opA(1:8) | opB(1:8)) &amp; ~(opA(1:8) &amp; opB(1:8)));
    <span class="comment">%As a note: there is a function xor(a,b) which would have served the</span>
    <span class="comment">%purpose here, but that doesn't show what exactly is going on in the</span>
    <span class="comment">%ALU because although an XOR is a logic gate, it is just essentially an</span>
    <span class="comment">%OR, two ANDs, and a NOT gate</span>

    printoutput(numsXORed,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonOnesComplement,<span class="string">'Value'</span>)
    <span class="comment">%goes through opA element by element and sets the onesCompA in that</span>
    <span class="comment">%column equal to the inverted value of opA (1 if opA = 0, 0 if opA = 1)</span>
    onesCompA(1:8) = ~opA(1:8);

    printoutput(onesCompA,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonLeft,<span class="string">'Value'</span>)
    <span class="keyword">for</span> counter = 1:+1:8    <span class="comment">%scans from left to right</span>

        <span class="keyword">if</span> counter == 8 <span class="comment">%Checks to see if the counter is at the rightmost bit</span>

            opA(counter) = 0;   <span class="comment">%if it is, then set that digit to 0</span>
            <span class="comment">%(append a zero to the left shifted byte)</span>

            <span class="keyword">break</span>   <span class="comment">%breaks out of the for loop so no room for ambiguity(opA(8+1))</span>
        <span class="keyword">end</span>

        <span class="keyword">if</span> counter == 1 &amp;&amp; opA(counter) == 1    <span class="comment">%checks to see if there is a 1 in msb</span>

            carryout = 1;   <span class="comment">%if there is, set the status equal to 1</span>
        <span class="keyword">end</span>

        opA(counter) = opA(counter+1);  <span class="comment">%'shifts' each bit to the left</span>
    <span class="keyword">end</span>

    printoutput(opA,carryout,handles);

<span class="keyword">elseif</span> get(handles.buttonRight,<span class="string">'Value'</span>)
    <span class="keyword">for</span> counter = 8:-1:1    <span class="comment">%counts from right to left</span>
        <span class="comment">%no check here because even if there is a bit in the rightmost</span>
        <span class="comment">%location, it just dissapears</span>

        <span class="keyword">if</span> counter == 1
            <span class="comment">%need this here because if we don't add it, when opA(counter-1)</span>
            <span class="comment">%is at counter = 1, it will try to get the value of opA(0),</span>
            <span class="comment">%which doesnt exist and will throw and error</span>

            opA(counter) = 0;   <span class="comment">%sets the leftmost bit equal to zero</span>
            <span class="keyword">break</span>   <span class="comment">%exits the for loop</span>
        <span class="keyword">end</span>

        opA(counter) = opA(counter-1);  <span class="comment">%'shifts' each bit to the right</span>
    <span class="keyword">end</span>

    <span class="comment">%prints out the resulting values</span>
    printoutput(opA,carryout,handles);

<span class="keyword">end</span>

timev(6) = toc;

<span class="comment">%plots the time in milliseconds, with title Runtime, and axis labels of x</span>
<span class="comment">%and Time (ms)</span>
plot(timev*1000)
title(<span class="string">'Runtime'</span>)
xlabel(<span class="string">'x'</span>)
ylabel(<span class="string">'Time (ms)'</span>)
<span class="comment">%checks if the final value is greater than the current max Y val of plot</span>
<span class="keyword">if</span> timev(6)*1000 &gt; 20
    axis([1 6 0 40])
<span class="keyword">else</span>
    axis([1 6 0 20])
<span class="keyword">end</span>


<span class="keyword">function</span> [sum,carryout] =  addnumbers(operandA, operandB, carryout)
<span class="comment">%sum = operandA+operandB;</span>
sum = de2bi(0, 8, <span class="string">'left-msb'</span>);
<span class="keyword">for</span> counter = 8:-1:1
    <span class="keyword">if</span> operandA(counter) &amp;&amp; operandB(counter) &amp;&amp; sum(counter)
        <span class="comment">%checks to see if there is a one in column (counter) both the</span>
        <span class="comment">%operands and the output line, and if there is leave the output</span>
        <span class="comment">%line alone and add a one to the next most significant bit</span>
        sum(counter) = 1;

        <span class="comment">%this if statement is checking if the for loop is at the very last</span>
        <span class="comment">%element of the array, and if it is the next msb is not</span>
        <span class="comment">%(counter-1), but carryout</span>
        <span class="keyword">if</span> counter == 1
            carryout = 1;
        <span class="keyword">else</span>
            sum(counter-1) = 1;
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> (operandA(counter) &amp;&amp; operandB(counter)) || (operandA(counter) &amp;&amp; sum(counter)) || (operandB(counter) &amp;&amp; sum(counter))
        <span class="comment">%checks to see if there are any combination of two 1s in column</span>
        <span class="comment">%(counter) and if there are add one to the next most significant</span>
        <span class="comment">%bit and set current bit of sum to 0</span>
        sum(counter) = 0;

        <span class="comment">%checks if last element to be checked</span>
        <span class="keyword">if</span> counter == 1
            carryout = 1;
        <span class="keyword">else</span>
            sum(counter-1) = 1;
        <span class="keyword">end</span>
    <span class="keyword">elseif</span> (operandA(counter) || operandB(counter) || sum(counter))
        <span class="comment">%checks to see if there are any ones at all, and if there are set</span>
        <span class="comment">%the current sum(counter) to 1</span>
        sum(counter) = 1;
    <span class="keyword">end</span>
<span class="keyword">end</span>



<span class="keyword">function</span> [twoscompvar,carryout] = twoscomp(opA)
<span class="comment">%in order to get the twos complement of a number, we first invert the</span>
<span class="comment">%operand  A, which we do by putting the NOT (~) symbol in front of opA in</span>
<span class="comment">%the addnumbers() function</span>
carryout = 0;
twoscompvar = addnumbers(~opA, de2bi(1,8,<span class="string">'left-msb'</span>), carryout);


<span class="keyword">function</span> operandA_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to operandA (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of operandA as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of operandA as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> operandA_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to operandA (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>



<span class="keyword">function</span> operandB_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to operandB (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of operandB as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of operandB as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> operandB_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to operandB (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="keyword">function</span> printoutput(primaryoutput, statusoutput, handles)

bione = de2bi(1,8,<span class="string">'left-msb'</span>);

<span class="keyword">if</span> get(handles.checkConvert,<span class="string">'Value'</span>)
    set(handles.textDecimalOut,<span class="string">'String'</span>,(-bi2de(addnumbers(~primaryoutput,bione),<span class="string">'left-msb'</span>)))
<span class="keyword">else</span>
    set(handles.textDecimalOut,<span class="string">'String'</span>,bi2de(primaryoutput,<span class="string">'left-msb'</span>))
<span class="keyword">end</span>
set(handles.outputdisplaytext,<span class="string">'String'</span>,num2str(primaryoutput))
set(handles.outputstatus,<span class="string">'String'</span>,num2str(statusoutput))




<span class="comment">% --- Executes on button press in buttonAdd.</span>
<span class="keyword">function</span> buttonAdd_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonAdd (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonAdd</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="keyword">function</span> carryinput_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to carryinput (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hints: get(hObject,'String') returns contents of carryinput as text</span>
<span class="comment">%        str2double(get(hObject,'String')) returns contents of carryinput as a double</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> carryinput_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to carryinput (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: edit controls usually have a white background on Windows.</span>
<span class="comment">%       See ISPC and COMPUTER.</span>
<span class="keyword">if</span> ispc &amp;&amp; isequal(get(hObject,<span class="string">'BackgroundColor'</span>), get(0,<span class="string">'defaultUicontrolBackgroundColor'</span>))
    set(hObject,<span class="string">'BackgroundColor'</span>,<span class="string">'white'</span>);
<span class="keyword">end</span>


<span class="comment">% --- Executes on button press in buttonAddCarry.</span>
<span class="keyword">function</span> buttonAddCarry_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonAddCarry (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonAddCarry</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'on'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="comment">% --- Executes on button press in buttonSubtract.</span>
<span class="keyword">function</span> buttonSubtract_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonSubtract (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonSubtract</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="comment">% --- Executes on button press in buttonSubBorrow.</span>
<span class="keyword">function</span> buttonSubBorrow_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonSubBorrow (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonSubBorrow</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'on'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="comment">% --- Executes on button press in buttonTwosComplement.</span>
<span class="keyword">function</span> buttonTwosComplement_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonTwosComplement (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonTwosComplement</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);


<span class="comment">% --- Executes on button press in buttonIncrement.</span>
<span class="keyword">function</span> buttonIncrement_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonIncrement (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonIncrement</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);


<span class="comment">% --- Executes on button press in buttonDecrement.</span>
<span class="keyword">function</span> buttonDecrement_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonDecrement (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonDecrement</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);


<span class="comment">% --- Executes on button press in buttonAND.</span>
<span class="keyword">function</span> buttonAND_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonAND (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonAND</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="comment">% --- Executes on button press in buttonOR.</span>
<span class="keyword">function</span> buttonOR_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonOR (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonOR</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="comment">% --- Executes on button press in buttonXOR.</span>
<span class="keyword">function</span> buttonXOR_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonXOR (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonXOR</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'on'</span>);


<span class="comment">% --- Executes on button press in buttonOnesComplement.</span>
<span class="keyword">function</span> buttonOnesComplement_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonOnesComplement (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonOnesComplement</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);


<span class="comment">% --- Executes on button press in buttonLeft.</span>
<span class="keyword">function</span> buttonLeft_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonLeft (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonLeft</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);


<span class="comment">% --- Executes on button press in buttonRight.</span>
<span class="keyword">function</span> buttonRight_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to buttonRight (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of buttonRight</span>
set(handles.carryinput,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.carryinput,<span class="string">'String'</span>,<span class="string">'0'</span>);
set(handles.operandB,<span class="string">'Enable'</span>,<span class="string">'off'</span>);
set(handles.operandB,<span class="string">'String'</span>,<span class="string">'0'</span>);



<span class="comment">% --- Executes on button press in checkConvert.</span>
<span class="keyword">function</span> checkConvert_Callback(hObject, eventdata, handles)
<span class="comment">% hObject    handle to checkConvert (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    structure with handles and user data (see GUIDATA)</span>

<span class="comment">% Hint: get(hObject,'Value') returns toggle state of checkConvert</span>


<span class="comment">% --- Executes during object creation, after setting all properties.</span>
<span class="keyword">function</span> axes1_CreateFcn(hObject, eventdata, handles)
<span class="comment">% hObject    handle to axes1 (see GCBO)</span>
<span class="comment">% eventdata  reserved - to be defined in a future version of MATLAB</span>
<span class="comment">% handles    empty - handles not created until after all CreateFcns called</span>

<span class="comment">% Hint: place code in OpeningFcn to populate axes1</span>
axes(hObject)
title(<span class="string">'Runtime'</span>)
xlabel(<span class="string">'x'</span>)
ylabel(<span class="string">'Time (ms)'</span>)
axis(hObject,[1 6 0 20])
</pre><img vspace="5" hspace="5" src="ALU_emulation_01.png" style="width:1128px;height:752px;" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017a</a><br></p></div><!--
##### SOURCE BEGIN #####
function varargout = ALU_emulation(varargin)
% ALU_EMULATION MATLAB code for ALU_emulation.fig
%      ALU_EMULATION, by itself, creates a new ALU_EMULATION or raises the existing
%      singleton*.
%
%      H = ALU_EMULATION returns the handle to a new ALU_EMULATION or the handle to
%      the existing singleton*.
%
%      ALU_EMULATION('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in ALU_EMULATION.M with the given input arguments.
%
%      ALU_EMULATION('Property','Value',...) creates a new ALU_EMULATION or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the APPALU before ALU_emulation_OpeningFcn gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to ALU_emulation_OpeningFcn via varargin.
%
%      *See APPALU Options on GUIDE's Tools menu.  Choose "APPALU allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help ALU_emulation

% Last Modified by GUIDE v2.5 09-May-2017 07:48:40

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @ALU_emulation_OpeningFcn, ...
                   'gui_OutputFcn',  @ALU_emulation_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% REPLACE_WITH_DASH_DASH- Executes just before ALU_emulation is made visible.
function ALU_emulation_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to ALU_emulation (see VARARGIN)

% Choose default command line output for ALU_emulation
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes ALU_emulation wait for user response (see UIRESUME)
% uiwait(handles.appalu);


% REPLACE_WITH_DASH_DASH- Outputs from this function are returned to the command line.
function varargout = ALU_emulation_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonExit.
function buttonExit_Callback(hObject, eventdata, handles)
% hObject    handle to buttonExit (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

%this line deletes the shell of the program, which causes the program to
%close
delete(handles.appalu)


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonRun.
function buttonRun_Callback(hObject, eventdata, handles)
% hObject    handle to buttonRun (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

axes(handles.axes1);
cla;
tic;

timev(1) = toc;
%by default the output will not be in twos complement format, so we want
%the text box that displays that the output is in twos complement notation
%to invisible
set(handles.twoscomptextbox,'Visible','off');
set(handles.checkConvert,'Visible','off');


%these if statements check if either of the input operands are blank, and
%if they are puts a 0 in them so the program does not throw any errors
if get(handles.operandA,'String') == ""
    set(handles.operandA,'String','0');
end
if get(handles.operandB,'String') == ""
    set(handles.operandB,'String','0');
end
if get(handles.carryinput,'String') == ""
    set(handles.carryinput,'String','0');
end

timev(2) = toc;

%these lines convert the values in the input boxes from string to unsigned
%8 bit integer values
opA = str2num(get(handles.operandA,'String'));
cast(opA,'uint8');
opB = str2num(get(handles.operandB,'String')); %#ok<*ST2NM>
cast(opB,'uint8');
%the #ok<*ST2NM> is included to prevent str2num from showing a warning

%these lines make sure the ALU only takes in the first eight bits of data
%passed to it in each operand input, as would happen in a real ALU
opA = mod(opA,256);
opB = mod(opB,256);
    
%these two set() statements are what display the inputs as decimal numbers
%in the Display container.
set(handles.textDecimalA,'String',opA)
set(handles.textDecimalB,'String',opB)

timev(3) = toc;

%these lines convert each operand to the binary 8 bit equivalent of the
%integers that were input in the operandA and operandB text boxes.  de2bi()
%was used here instead of creating our own function because in creating our
%own function that would utilize dividing the number by 2^n in an iterative
%statement, we encountered the issue that because Matlab is such a high
%level program, it "smartly" deals with dividing two integer values by
%assigning the value that they are equal to to be a float type, so we were
%getting back decimals.  Even using a function that returned the value of
%the two as an integer still rounded up if the decimal was greater than .5.
%Because of these, and since our project was not to create a decimal to
%binary converter, we utilizes one of the functions that was available to
%us through the Matlab library.
opA = de2bi(opA,8,'left-msb');
opB = de2bi(opB,8,'left-msb');

%these set the strings of the text boxes that have the tags textBinaryA and
%textBinaryB to the string equivalent of each binary number
set(handles.textBinaryA,'String',num2str(opA));
set(handles.textBinaryB,'String',num2str(opB));

timev(4) = toc;

%this checks the validity of the value entered in the carryin text box.  If
%it is greater than 1, the value will be set down to 1 as the only valid
%carryin values are 1 or 0. There is no way for an actual ALU to take in any
%input in carryin that is greater than 1.
carryin = str2num(get(handles.carryinput,'String'));
if carryin > 1
    set(handles.carryinput,'String',"1")
    carryin = 1;
end
set(handles.textcarryin,'String',num2str(carryin));
carryin = de2bi(carryin,8,'left-msb');
carryout = 0;

%defines a binary 1 to be used in functionalities such as increment and
%decrement
bione = de2bi(1,8,'left-msb');

timev(5) = toc;

%these ifs check which radio button is selected (the buttons in the Opcode
%panel) and based on that, perform some function specified
if get(handles.buttonAdd,'Value')
    %calls funtion addnumbers() to add opA and opB, and also needs carryout
    %as it is used within the function and then returned
    [sum,carryout] = addnumbers(opA, opB, carryout);
    
    %print out the sum in the main output, carryout in the status output,
    %and handles is needed in order to actually access the various elements
    %in the gui that display these values
    printoutput(sum,carryout,handles)
    
elseif get(handles.buttonSubtract,'Value')
    %calls function addnumbers() to add operand A with the twos complement
    %of operand B, which is how subtraction is done in an ALU
    [diff,carryout] = addnumbers(opA, twoscomp(opB), carryout);
    
    %these lines print the result of adding the two, and if operand B was
    %larger than operand A, it makes the text box saying "Twos Comp"
    %visible, as the result will be in twos complement form
    if bi2de(opB,'left-msb') > bi2de(opA,'left-msb')
        set(handles.twoscomptextbox,'Visible','on');
        set(handles.checkConvert,'Visible','on');
    end
    printoutput(diff,carryout,handles);
    
elseif get(handles.buttonAddCarry,'Value')
    %these lines add the carryin to opA, and that sum is then added to opB
    [sum,carryout] = addnumbers(carryin, opA, carryout);
    [sum,carryout] = addnumbers(sum, opB, carryout);
    
    printoutput(sum,carryout,handles)
    
elseif get(handles.buttonSubBorrow,'Value')
    %this section is very similar to the previous subtraction section, with
    %the change being that the carryin bit is added to opA before adding
    %that to the two's complement of opB
    [opAtotal,carryout] = addnumbers(opA, carryin, carryout);
    [diff,carryout] = addnumbers(opAtotal, twoscomp(opB), carryout);
    
    %checks if the output is in two's complement format
    if bi2de(opB,'left-msb')>bi2de(opAtotal,'left-msb')
        set(handles.twoscomptextbox,'Visible','on');
        set(handles.checkConvert,'Visible','on');
    end
    
    printoutput(diff,carryout,handles);
    
elseif get(handles.buttonTwosComplement,'Value')
    %calls the twoscomp() of opA
    [mainout,carryout] = twoscomp(opA);
    
    printoutput(mainout,carryout,handles)
    %enables the box indicating the value is in two's complement format and
    %the check box to convert that to it's signed integer value.
    set(handles.twoscomptextbox,'Visible','on');
    set(handles.checkConvert,'Visible','on');
    
elseif get(handles.buttonIncrement,'Value')
    %adds opA with binary one, incrementing opA by 1
    [sum,carryout] = addnumbers(opA, bione, carryout);
    
    printoutput(sum,carryout,handles);
    
elseif get(handles.buttonDecrement,'Value')
    %this line gets the two's complement of bione and sets twosOne equal to
    %that value
    [twosOne, carryout] = twoscomp(bione);
    
    [sum,carryout] = addnumbers(opA, twosOne, carryout);
    
    %this checks if operand A is equal to 0, the only instance where the
    %output of this function can be in two's complement form
    if bi2de(opA) == 0
        set(handles.twoscomptextbox,'Visible','on');
        set(handles.checkConvert,'Visible','on');
    end
    
    printoutput(sum,carryout,handles);
    
elseif get(handles.buttonAND,'Value')
    %steps through each element of the arrays opA and opB and checks if
    %both are equal to one: if they are, then the value at that column of
    %anded is set to one; otherwise, it is set to 0
    anded(1:8) = opA(1:8) & opB(1:8);
    
    printoutput(anded,carryout,handles);
    
elseif get(handles.buttonOR,'Value')
    %steps through element by element of the arrays and if either element
    %it is currently checking is a 1, it outputs a 1 to numsORed; otherwise
    %it is set to 0
    numsORed(1:8) = opA(1:8) | opB(1:8);
    
    printoutput(numsORed,carryout,handles);
    
elseif get(handles.buttonXOR,'Value')
    %goes through each element of each array one by one: first it checks if
    %at least one element has a value of 1 in that column; then it gets the
    %NANDed value of the two anded together, which is to say it makes sure
    %that not both have a value of 1; finally it sets numsXORed at that
    %column equal to 1 if both of these criteria have been met, else 0
    numsXORed(1:8) = ((opA(1:8) | opB(1:8)) & ~(opA(1:8) & opB(1:8)));
    %As a note: there is a function xor(a,b) which would have served the
    %purpose here, but that doesn't show what exactly is going on in the
    %ALU because although an XOR is a logic gate, it is just essentially an
    %OR, two ANDs, and a NOT gate
    
    printoutput(numsXORed,carryout,handles);
    
elseif get(handles.buttonOnesComplement,'Value')
    %goes through opA element by element and sets the onesCompA in that
    %column equal to the inverted value of opA (1 if opA = 0, 0 if opA = 1)
    onesCompA(1:8) = ~opA(1:8);
    
    printoutput(onesCompA,carryout,handles);
    
elseif get(handles.buttonLeft,'Value')
    for counter = 1:+1:8    %scans from left to right
        
        if counter == 8 %Checks to see if the counter is at the rightmost bit
            
            opA(counter) = 0;   %if it is, then set that digit to 0
            %(append a zero to the left shifted byte)
            
            break   %breaks out of the for loop so no room for ambiguity(opA(8+1))
        end
        
        if counter == 1 && opA(counter) == 1    %checks to see if there is a 1 in msb
            
            carryout = 1;   %if there is, set the status equal to 1
        end
        
        opA(counter) = opA(counter+1);  %'shifts' each bit to the left
    end
    
    printoutput(opA,carryout,handles);

elseif get(handles.buttonRight,'Value')
    for counter = 8:-1:1    %counts from right to left
        %no check here because even if there is a bit in the rightmost
        %location, it just dissapears
        
        if counter == 1
            %need this here because if we don't add it, when opA(counter-1)
            %is at counter = 1, it will try to get the value of opA(0),
            %which doesnt exist and will throw and error
            
            opA(counter) = 0;   %sets the leftmost bit equal to zero
            break   %exits the for loop
        end
        
        opA(counter) = opA(counter-1);  %'shifts' each bit to the right
    end
    
    %prints out the resulting values
    printoutput(opA,carryout,handles);
    
end

timev(6) = toc;

%plots the time in milliseconds, with title Runtime, and axis labels of x
%and Time (ms)
plot(timev*1000)
title('Runtime')
xlabel('x')
ylabel('Time (ms)')
%checks if the final value is greater than the current max Y val of plot
if timev(6)*1000 > 20
    axis([1 6 0 40])
else
    axis([1 6 0 20])
end


function [sum,carryout] =  addnumbers(operandA, operandB, carryout)
%sum = operandA+operandB;
sum = de2bi(0, 8, 'left-msb');
for counter = 8:-1:1
    if operandA(counter) && operandB(counter) && sum(counter)
        %checks to see if there is a one in column (counter) both the
        %operands and the output line, and if there is leave the output
        %line alone and add a one to the next most significant bit
        sum(counter) = 1;
        
        %this if statement is checking if the for loop is at the very last
        %element of the array, and if it is the next msb is not
        %(counter-1), but carryout
        if counter == 1
            carryout = 1;
        else
            sum(counter-1) = 1;
        end
    elseif (operandA(counter) && operandB(counter)) || (operandA(counter) && sum(counter)) || (operandB(counter) && sum(counter))
        %checks to see if there are any combination of two 1s in column
        %(counter) and if there are add one to the next most significant
        %bit and set current bit of sum to 0
        sum(counter) = 0;
        
        %checks if last element to be checked
        if counter == 1
            carryout = 1;
        else
            sum(counter-1) = 1;
        end
    elseif (operandA(counter) || operandB(counter) || sum(counter))
        %checks to see if there are any ones at all, and if there are set
        %the current sum(counter) to 1
        sum(counter) = 1;
    end
end



function [twoscompvar,carryout] = twoscomp(opA)
%in order to get the twos complement of a number, we first invert the
%operand  A, which we do by putting the NOT (~) symbol in front of opA in
%the addnumbers() function
carryout = 0;
twoscompvar = addnumbers(~opA, de2bi(1,8,'left-msb'), carryout);


function operandA_Callback(hObject, eventdata, handles)
% hObject    handle to operandA (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of operandA as text
%        str2double(get(hObject,'String')) returns contents of operandA as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function operandA_CreateFcn(hObject, eventdata, handles)
% hObject    handle to operandA (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



function operandB_Callback(hObject, eventdata, handles)
% hObject    handle to operandB (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of operandB as text
%        str2double(get(hObject,'String')) returns contents of operandB as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function operandB_CreateFcn(hObject, eventdata, handles)
% hObject    handle to operandB (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


function printoutput(primaryoutput, statusoutput, handles)

bione = de2bi(1,8,'left-msb');

if get(handles.checkConvert,'Value')
    set(handles.textDecimalOut,'String',(-bi2de(addnumbers(~primaryoutput,bione),'left-msb')))
else
    set(handles.textDecimalOut,'String',bi2de(primaryoutput,'left-msb'))
end
set(handles.outputdisplaytext,'String',num2str(primaryoutput))
set(handles.outputstatus,'String',num2str(statusoutput))




% REPLACE_WITH_DASH_DASH- Executes on button press in buttonAdd.
function buttonAdd_Callback(hObject, eventdata, handles)
% hObject    handle to buttonAdd (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonAdd
set(handles.carryinput,'Enable','off'); 
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','on');


function carryinput_Callback(hObject, eventdata, handles)
% hObject    handle to carryinput (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: get(hObject,'String') returns contents of carryinput as text
%        str2double(get(hObject,'String')) returns contents of carryinput as a double


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function carryinput_CreateFcn(hObject, eventdata, handles)
% hObject    handle to carryinput (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: edit controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonAddCarry.
function buttonAddCarry_Callback(hObject, eventdata, handles)
% hObject    handle to buttonAddCarry (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonAddCarry
set(handles.carryinput,'Enable','on');
set(handles.operandB,'Enable','on');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonSubtract.
function buttonSubtract_Callback(hObject, eventdata, handles)
% hObject    handle to buttonSubtract (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonSubtract
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','on');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonSubBorrow.
function buttonSubBorrow_Callback(hObject, eventdata, handles)
% hObject    handle to buttonSubBorrow (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonSubBorrow
set(handles.carryinput,'Enable','on');
set(handles.operandB,'Enable','on');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonTwosComplement.
function buttonTwosComplement_Callback(hObject, eventdata, handles)
% hObject    handle to buttonTwosComplement (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonTwosComplement
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','off');
set(handles.operandB,'String','0');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonIncrement.
function buttonIncrement_Callback(hObject, eventdata, handles)
% hObject    handle to buttonIncrement (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonIncrement
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','off');
set(handles.operandB,'String','0');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonDecrement.
function buttonDecrement_Callback(hObject, eventdata, handles)
% hObject    handle to buttonDecrement (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonDecrement
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','off');
set(handles.operandB,'String','0');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonAND.
function buttonAND_Callback(hObject, eventdata, handles)
% hObject    handle to buttonAND (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonAND
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','on');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonOR.
function buttonOR_Callback(hObject, eventdata, handles)
% hObject    handle to buttonOR (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonOR
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','on');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonXOR.
function buttonXOR_Callback(hObject, eventdata, handles)
% hObject    handle to buttonXOR (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonXOR
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','on');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonOnesComplement.
function buttonOnesComplement_Callback(hObject, eventdata, handles)
% hObject    handle to buttonOnesComplement (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonOnesComplement
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','off');
set(handles.operandB,'String','0');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonLeft.
function buttonLeft_Callback(hObject, eventdata, handles)
% hObject    handle to buttonLeft (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonLeft
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','off');
set(handles.operandB,'String','0');


% REPLACE_WITH_DASH_DASH- Executes on button press in buttonRight.
function buttonRight_Callback(hObject, eventdata, handles)
% hObject    handle to buttonRight (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of buttonRight
set(handles.carryinput,'Enable','off');
set(handles.carryinput,'String','0');
set(handles.operandB,'Enable','off');
set(handles.operandB,'String','0');



% REPLACE_WITH_DASH_DASH- Executes on button press in checkConvert.
function checkConvert_Callback(hObject, eventdata, handles)
% hObject    handle to checkConvert (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hint: get(hObject,'Value') returns toggle state of checkConvert


% REPLACE_WITH_DASH_DASH- Executes during object creation, after setting all properties.
function axes1_CreateFcn(hObject, eventdata, handles)
% hObject    handle to axes1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: place code in OpeningFcn to populate axes1
axes(hObject)
title('Runtime')
xlabel('x')
ylabel('Time (ms)')
axis(hObject,[1 6 0 20])

##### SOURCE END #####
--></body></html>